using static IterableHelpers;
using System.Linq.Expressions;
using FxCs;

public partial class Program
{
	public static void HighOrderFunctions()
	{
		// Custom - ForEach
		ForEach(WriteLine,
			Map(x => x * 10,
				Filter(x => x % 2 == 1,
					Naturals(5))));


		// Spread Element after C#12
		int[] result = [
			.. Naturals(3),
			.. Naturals(3),
			.. Naturals(3)
		];

		// native foreach
		foreach (var n in Map(x => x * 10, Filter(x => x % 2 == 1, Naturals(5))))
		{
			WriteLine(n);
		}

		Map(x => x * 10, Enumerable.Range(1, 10)).ForEach(WriteLine);
	}

	private record User(string Name);

	public static void TypeSystemExample()
	{

		// C#의 타입 시스템 vs Typescript

		// Type Inference
		// High Order Function
		// Generic?
		// Purpose is safety and good maintainance
		// OOP and FunctionProgramming
		// Introduce as root of FunctionalProgramming

		WriteLine(Add(10, 12));

		static int Add(int a, int b)
		{
			return a + b;
		}

		// The type name is generated by the compiler and is not available at the source code level.
		// Warning: This is Literal Object
		var user = new
		{
			Name = "Marty",
			Age = 30,
		};

		// Compile Error anonymous object is readonly property
		// user.Name = 123;


		var a = Identity("h1");
		var b = Identity(1);
		var f = Identity((int n) => n % 2 == 1);
		var e = Identity(new User("E"));
		static T Identity<T>(T arg) => arg;

		var getFive = Constant(5);
		var ten = getFive() + getFive();
		WriteLine(ten);

		var getHi = Constant("Hi");
		WriteLine(getHi() + getHi());

	}

	public static void CustomReduceExample()
	{
		int[] array = [1, 2, 3];
		var sum = Reduce((acc, a) => acc + a, 0, array);
		WriteLine(sum);

		string[] strings = ["a", "b", "c"];
		var abc = Reduce((acc, a) => $"{acc}{a}", string.Empty, strings);
		WriteLine(abc);

		int[] array2 = [1, 2, 3];
		var sum2 = Reduce((a, b) => a + b, array2);

		string[] words = ["hello", "beautiful", "world"];

		WriteLine(Reduce((a, b) => $"{a} {b}", words));

		// C# Enumerable.Aggregate
		WriteLine(words.Aggregate((a, b) => $"{a} {b}"));
	}

	public static void DirectorySearchExample()
	{
		ForEach(WriteLine,
			Map(filename => Path.GetFileName(filename),
				Filter(filename => filename.EndsWith(".cs"),
					Directory.EnumerateFiles(Environment.CurrentDirectory))));
	}

	public static void MethodChainingExample()
	{
		var num = Naturals(5)
			.ToFx()
			.Filter(n => n % 2 == 1)
			.Map(n => n * 10)
			.Reduce((a, b) => a + b);

		WriteLine(num);

		var num2 = Naturals(5)
			.ToFx()
			.Filter(n => n % 2 == 1)
			.Map(n => n * 10)
			.Reduce((a, b) => a + b, 10);

		WriteLine(num2);
	}

	// type Evaluate<A, B> = [(...args: A[]) => B, ...A[]];
	// function evaluation<A, B>(expr: Evaluatable<A,B>) {
	//   const [fn, ...args] = expr;
	//   return fn(...args)
	// }

	// 뭔가 잘 안된다. 코드를 데이터로 나타내는 타입을 만들어야한다.
	// C#에서는 데이터 타입을 강하게 정의해야한다.
	// Generic이 적용된 데이터 타입을 정의하려면 class가 필요하다.

	// https://learn.microsoft.com/en-us/dotnet/csharp/advanced-topics/expression-trees/
	public record Evaluatable<A, B>(Func<A[], B> fn, A[] values); // TODO: Code as Data?
	public static B Evaluation<A, B>(Evaluatable<A, B> evalutable)
	{
		var (fn, values) = evalutable;
		return fn([.. values]);
	}

	public static void EvaluateCodeAsData()
	{
		// type Evaluate<A, B> = [(...args: A[]) => B, ...A[]];
		// function evaluation<A, B>(expr: Evaluatable<A,B>) {
		//   const [fn, ...args] = expr;
		//   return fn(...args)
		// }

		// 뭔가 잘 안된다. 코드를 데이터로 나타내는 타입을 만들어야한다.
		// C#에서는 데이터 타입을 강하게 정의해야한다.
		// Generic이 적용된 데이터 타입을 정의하려면 class가 필요하다.

		var add1 = (int[] values) => values.Sum();
		int result = Evaluation(new Evaluatable<int, int>(add1, [1, 2]));
		WriteLine(result);

		var add2 = (int a, int b) => a + b;
		var result2 = add2(1, 2);

		// S - Expression
		var a = Expression.Parameter(typeof(int), "a");
		var b = Expression.Parameter(typeof(int), "b");
		var body = Expression.Add(a, b);
		var addExpression = Expression.Lambda<Func<int, int, int>>(body, a, b);
		var result3 = addExpression.Compile().Invoke(1, 2);
		WriteLine(result3);


		// https://learn.microsoft.com/en-us/dotnet/csharp/advanced-topics/expression-trees/

	}

	public static void MakeClassToList()
	{
		ForEach(WriteLine,
					Map(x => x * 10,
						Filter(x => x % 2 == 1,
							Naturals(5))));

		Naturals(5).ToFx()
			.Filter(x => x % 2 == 1)
			.Map(x => x * 10)
			.ForEach(WriteLine);


		Naturals(4).ToFx()
			.Reject(n => n % 2 == 1) // Reject!
			.Map(a => a + 10)
			.Take(2)
			.ForEach(WriteLine);

		WriteLine("===========");

		Naturals(4).ToFx()
			.Filter(n => n % 2 == 1)
			.Map(a => a + 10)
			.Take(2)
			.ForEach(WriteLine);

		WriteLine("===========");

		Naturals(6).ToFx()
			.Filter(n => n % 2 == 1)
			.Map(n => n * 10)
			.To(iterable => iterable.ToList())
			.FxSort((a, b) => b - a)
			.ForEach(WriteLine);

		WriteLine("===========");

		Naturals(6).ToFx()
			.Filter(n => n % 2 == 1)
			.Map(n => n * 10)
			.To(iterable => iterable.ToHashSet())
			.Except(new HashSet<int>([10, 20, 30]))
			.ForEach(WriteLine);

		// .ExtForEach(WriteLine);

		WriteLine("===========");

		var result = Fx.From([5, 2, 3, 1, 4, 5, 3])
			.Filter(n => n % 2 == 1)
			.Map(n => n * 10)
			.Chain(iterable => new HashSet<int>(iterable))
			.Reduce((a, b) => a + b);

		WriteLine(result);

	}


}
